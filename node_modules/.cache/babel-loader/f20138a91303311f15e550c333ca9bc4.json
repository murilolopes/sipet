{"remainingRequest":"/home/murilo/code/murilo/sipet/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js!/home/murilo/code/murilo/sipet/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/home/murilo/code/murilo/sipet/src/router/index.js","dependencies":[{"path":"/home/murilo/code/murilo/sipet/src/router/index.js","mtime":1571666396000},{"path":"/home/murilo/code/murilo/sipet/.babelrc","mtime":1587599733863},{"path":"/home/murilo/code/murilo/sipet/node_modules/cache-loader/dist/cjs.js","mtime":1583949852443},{"path":"/home/murilo/code/murilo/sipet/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":1583949836565},{"path":"/home/murilo/code/murilo/sipet/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1583949846865}],"contextDependencies":[],"result":["import Vue from 'vue';\nimport VueRouter from 'vue-router'; // https://github.com/declandewet/vue-meta\n\nimport VueMeta from 'vue-meta'; // Adds a loading bar at the top during page loads.\n\nimport NProgress from 'nprogress/nprogress';\nimport store from '@state/store';\nimport { allRoutes } from './routes';\nVue.use(VueRouter);\nVue.use(VueMeta, {\n  // The component option name that vue-meta looks for meta info on.\n  keyName: 'page'\n});\nconst router = new VueRouter({\n  routes: allRoutes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  }\n\n}); // Before each route evaluates...\n\nrouter.beforeEach((routeTo, routeFrom, next) => {\n  // If this isn't an initial page load...\n  if (routeFrom.name !== null) {\n    // Start the route progress bar.\n    NProgress.start();\n  } // Check if auth is required on this route\n  // (including nested routes).\n\n\n  const authRequired = routeTo.matched.some(route => route.meta.authRequired); // If auth isn't required for the route, just continue.\n\n  if (!authRequired) return next(); // If auth is required and the user is logged in...\n\n  if (store.getters['auth/loggedIn']) {\n    // Validate the local user token...\n    return store.dispatch('auth/validate').then(validUser => {\n      // Then continue if the token still represents a valid user,\n      // otherwise redirect to login.\n      validUser ? next() : redirectToLogin();\n    });\n  } // If auth is required and the user is NOT currently logged in,\n  // redirect to login.\n\n\n  redirectToLogin();\n\n  function redirectToLogin() {\n    // Pass the original route to the login component\n    next({\n      name: 'login',\n      query: {\n        redirectFrom: routeTo.fullPath\n      }\n    });\n  }\n});\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              if (routeFrom.name === args[0].name) {\n                // Complete the animation of the route progress bar.\n                NProgress.done();\n              } // Complete the redirect.\n\n\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    } // If a `beforeResolve` hook chose to redirect, just return.\n\n  } catch (error) {\n    return;\n  } // If we reach this point, continue resolving the route.\n\n\n  next();\n}); // When each route is finished evaluating...\n\nrouter.afterEach((routeTo, routeFrom) => {\n  // Complete the animation of the route progress bar.\n  NProgress.done();\n});\nexport default router;",{"version":3,"sources":["/home/murilo/code/murilo/sipet/src/router/index.js"],"names":["Vue","VueRouter","VueMeta","NProgress","store","allRoutes","use","keyName","router","routes","mode","scrollBehavior","to","from","savedPosition","x","y","beforeEach","routeTo","routeFrom","next","name","start","authRequired","matched","some","route","meta","getters","dispatch","then","validUser","redirectToLogin","query","redirectFrom","fullPath","beforeResolve","Promise","resolve","reject","args","length","done","Error","error","afterEach"],"mappings":"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","sourcesContent":["import Vue from 'vue'\nimport VueRouter from 'vue-router'\n// https://github.com/declandewet/vue-meta\nimport VueMeta from 'vue-meta'\n// Adds a loading bar at the top during page loads.\nimport NProgress from 'nprogress/nprogress'\nimport store from '@state/store'\nimport { allRoutes } from './routes'\n\nVue.use(VueRouter)\nVue.use(VueMeta, {\n  // The component option name that vue-meta looks for meta info on.\n  keyName: 'page',\n})\n\nconst router = new VueRouter({\n  routes: allRoutes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { x: 0, y: 0 }\n    }\n  },\n})\n\n// Before each route evaluates...\nrouter.beforeEach((routeTo, routeFrom, next) => {\n  // If this isn't an initial page load...\n  if (routeFrom.name !== null) {\n    // Start the route progress bar.\n    NProgress.start()\n  }\n\n  // Check if auth is required on this route\n  // (including nested routes).\n  const authRequired = routeTo.matched.some((route) => route.meta.authRequired)\n\n  // If auth isn't required for the route, just continue.\n  if (!authRequired) return next()\n\n  // If auth is required and the user is logged in...\n  if (store.getters['auth/loggedIn']) {\n    // Validate the local user token...\n    return store.dispatch('auth/validate').then((validUser) => {\n      // Then continue if the token still represents a valid user,\n      // otherwise redirect to login.\n      validUser ? next() : redirectToLogin()\n    })\n  }\n\n  // If auth is required and the user is NOT currently logged in,\n  // redirect to login.\n  redirectToLogin()\n\n  function redirectToLogin() {\n    // Pass the original route to the login component\n    next({ name: 'login', query: { redirectFrom: routeTo.fullPath } })\n  }\n})\n\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              if (routeFrom.name === args[0].name) {\n                // Complete the animation of the route progress bar.\n                NProgress.done()\n              }\n              // Complete the redirect.\n              next(...args)\n              reject(new Error('Redirected'))\n            } else {\n              resolve()\n            }\n          })\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve()\n        }\n      })\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return\n  }\n\n  // If we reach this point, continue resolving the route.\n  next()\n})\n\n// When each route is finished evaluating...\nrouter.afterEach((routeTo, routeFrom) => {\n  // Complete the animation of the route progress bar.\n  NProgress.done()\n})\n\nexport default router\n"]}]}